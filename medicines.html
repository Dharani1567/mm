{% extends "base.html" %}
{% block title %}Medicines - Medicine Manager{% endblock %}
{% block page_header %}Medicines{% endblock %}

{% block content %}
<div class="card-modern p-3 mb-3">
  <div class="d-flex flex-column flex-md-row gap-2 align-items-start align-items-md-center justify-content-between">
    <div class="d-flex gap-2 align-items-center">
      <input id="globalSearchBox" class="form-control form-control-sm" placeholder="Search medicines... (press Enter or wait)" />
      <button class="btn btn-sm btn-outline-secondary" id="btnExportCsv">Export CSV</button>
    </div>

    <div class="d-flex gap-2 align-items-center flex-wrap">
      <select id="filterExpiry" class="form-select form-select-sm" style="min-width:150px;">
        <option value="">All expiry</option>
        <option value="expired">Expired</option>
        <option value="near">Near expiry (≤30d)</option>
        <option value="ok">OK</option>
      </select>

      <select id="filterStock" class="form-select form-select-sm" style="min-width:150px;">
        <option value="">All stock</option>
        <option value="low">Low (&lt;10)</option>
        <option value="ok">Sufficient</option>
      </select>

      <select id="filterSupplier" class="form-select form-select-sm" style="min-width:180px;">
        <option value="">All suppliers</option>
      </select>

      <select id="filterCategory" class="form-select form-select-sm" style="min-width:180px;">
        <option value="">All categories</option>
      </select>
    </div>
  </div>
</div>

<div class="card-modern">
  <div class="table-responsive">
    <table class="table table-hover align-middle" id="medicinesTable">
      <thead class="table-light">
        <tr>
          <th class="sortable" data-key="medicine_id">ID <i class="bi bi-chevron-expand ms-1"></i></th>
          <th class="sortable" data-key="name">Name</th>
          <th class="sortable" data-key="batch_number">Batch</th>
          <th class="sortable" data-key="expiry_date">Expiry</th>
          <th class="sortable" data-key="quantity">Qty</th>
          <th>Supplier</th>
          <th>Price</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="medicinesTbody"></tbody>
    </table>
  </div>

  <div class="d-flex justify-content-between align-items-center p-3">
    <div>
      <small id="tableInfo" class="text-muted"></small>
    </div>

    <div class="d-flex gap-2 align-items-center">
      <button id="prevPage" class="btn btn-sm btn-outline-secondary">Prev</button>
      <span id="pageInfo" class="mx-1">1</span>
      <button id="nextPage" class="btn btn-sm btn-outline-secondary">Next</button>

      <select id="perPage" class="form-select form-select-sm" style="width:80px;">
        <option value="5">5</option>
        <option value="10" selected>10</option>
        <option value="25">25</option>
      </select>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
/*
  Medicines Page (Option B)
  - Client-side search, filter, sort, pagination
  - Requires backend endpoints:
    GET /medicines
    GET /suppliers
    GET /categories
    DELETE /medicines/<id>
    (Edit uses redirect to /update_medicine_page?id=)
*/
 // works with Flask
let allMeds = [];
let suppliers = [];
let categories = [];

let currentPage = 1;
let perPage = 10;
let currentSort = { key: 'medicine_id', dir: 'asc' };

function showToast(msg) {
  // small, unobtrusive message using alert fallback
  console.log('TOAST:', msg);
  // you can replace with nicer UI (Bootstrap toast) later
}

async function fetchSuppliersAndCategories() {
  try {
    const [sRes, cRes] = await Promise.all([
      fetch(`${API_BASE}/suppliers`),
      fetch(`${API_BASE}/categories`)
    ]);
    suppliers = await sRes.json();
    categories = await cRes.json();

    const supSelect = document.getElementById('filterSupplier');
    suppliers.forEach(s => {
      const opt = document.createElement('option');
      opt.value = s.supplier_id ?? s.supplier_id; // RealDictCursor might have keys
      opt.textContent = s.supplier_name || s.name || s.supplier_name || `#${s.supplier_id}`;
      supSelect.appendChild(opt);
    });

    const catSelect = document.getElementById('filterCategory');
    categories.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.category_id;
      opt.textContent = c.category_name || c.name || `#${c.category_id}`;
      catSelect.appendChild(opt);
    });

  } catch (e) {
    console.error('Error fetching suppliers/categories', e);
  }
}

function applyFiltersAndSort(meds) {
  const q = (document.getElementById('globalSearchBox').value || '').toLowerCase().trim();
  const expiryFilter = document.getElementById('filterExpiry').value;
  const stockFilter = document.getElementById('filterStock').value;
  const supplierFilter = document.getElementById('filterSupplier').value;
  const categoryFilter = document.getElementById('filterCategory').value;

  const today = new Date();

  let filtered = meds.filter(m => {
    // Search across several fields
    if (q) {
      const hay = `${m.name} ${m.batch_number || ''} ${m.medicine_id || ''}`.toLowerCase();
      if (!hay.includes(q)) return false;
    }

    // supplier
    if (supplierFilter) {
      const sid = String(m.supplier_id ?? '');
      if (sid !== supplierFilter) return false;
    }

    // category
    if (categoryFilter) {
      const cid = String(m.category_id ?? '');
      if (cid !== categoryFilter) return false;
    }

    // stock filter
    if (stockFilter === 'low' && (m.quantity === null || m.quantity >= 10)) return false;
    if (stockFilter === 'ok' && (m.quantity !== null && m.quantity < 10)) return false;

    // expiry filter
    if (expiryFilter) {
      if (!m.expiry_date) {
        if (expiryFilter !== 'ok') return false;
      } else {
        const ed = new Date(m.expiry_date);
        const diffDays = Math.ceil((ed - today) / (1000*3600*24));
        if (expiryFilter === 'expired' && diffDays >= 0) return false;
        if (expiryFilter === 'near' && (diffDays > 30 || diffDays < 0)) return false;
        if (expiryFilter === 'ok' && diffDays <= 30) return false;
      }
    }

    return true;
  });

  // sort
  const key = currentSort.key;
  const dir = currentSort.dir === 'asc' ? 1 : -1;
  filtered.sort((a,b) => {
    let va = a[key], vb = b[key];
    if (va == null) va = '';
    if (vb == null) vb = '';
    // try numeric
    if (!isNaN(Number(va)) && !isNaN(Number(vb))) {
      return (Number(va) - Number(vb)) * dir;
    }
    return String(va).localeCompare(String(vb)) * dir;
  });

  return filtered;
}

function renderTablePage(filtered) {
  perPage = parseInt(document.getElementById('perPage').value, 10) || 10;
  const total = filtered.length;
  const pages = Math.max(1, Math.ceil(total / perPage));
  if (currentPage > pages) currentPage = pages;

  const start = (currentPage - 1) * perPage;
  const end = start + perPage;
  const pageItems = filtered.slice(start, end);

  const tbody = document.getElementById('medicinesTbody');
  tbody.innerHTML = '';

  pageItems.forEach(m => {
    const expiry = m.expiry_date ? new Date(m.expiry_date) : null;
    let statusBadge = '';
    if (expiry) {
      const diffDays = Math.ceil((expiry - new Date())/(1000*3600*24));
      if (diffDays < 0) statusBadge = '<span class="badge bg-danger">Expired</span>';
      else if (diffDays <= 30) statusBadge = '<span class="badge bg-warning text-dark">Near expiry</span>';
    }
    if (m.quantity !== null && m.quantity < 10) statusBadge += ' <span class="badge bg-info text-dark">Low stock</span>';

    const supplierText = (function(){
      const s = suppliers.find(x => String(x.supplier_id) === String(m.supplier_id));
      return s ? (s.supplier_name || s.name || `#${s.supplier_id}`) : (m.supplier_id ? `#${m.supplier_id}` : '-');
    })();

    tbody.innerHTML += `
      <tr>
        <td>${m.medicine_id}</td>
        <td>
          <div class="fw-semibold">${m.name}</div>
          <div class="small text-muted">${m.batch_number || ''} ${statusBadge}</div>
        </td>
        <td>${m.batch_number || '-'}</td>
        <td>${m.expiry_date || '-'}</td>
        <td>${m.quantity ?? 0}</td>
        <td>${supplierText}</td>
        <td>${m.price != null ? '₹' + Number(m.price).toFixed(2) : '-'}</td>
        <td>
          <a class="btn btn-sm btn-outline-primary mb-1" href="/update_medicine_page?id=${m.medicine_id}"><i class="bi bi-pencil"></i></a>
          <button class="btn btn-sm btn-outline-danger mb-1" onclick="onDeleteMedicine(${m.medicine_id})"><i class="bi bi-trash"></i></button>
        </td>
      </tr>
    `;
  });

  document.getElementById('tableInfo').textContent = `Showing ${Math.min(total, start+1)} — ${Math.min(end, total)} of ${total}`;
  document.getElementById('pageInfo').textContent = `${currentPage}/${pages}`;
  document.getElementById('prevPage').disabled = currentPage <= 1;
  document.getElementById('nextPage').disabled = currentPage >= pages;
}

async function loadMedicinesPage() {
  try {
    const res = await fetch(`${API_BASE}/medicines`);
    allMeds = await res.json();
    // ensure numbers are typed correctly
    allMeds = allMeds.map(m => ({ ...m,
      quantity: m.quantity != null ? Number(m.quantity) : null,
      price: m.price != null ? Number(m.price) : null
    }));
    refreshTable();
  } catch (e) {
    console.error('Error loading medicines', e);
  }
}

function refreshTable() {
  const filtered = applyFiltersAndSort(allMeds);
  renderTablePage(filtered);
}

async function onDeleteMedicine(id) {
  if (!confirm('Delete medicine #' + id + '?')) return;
  try {
    const r = await fetch(`${API_BASE}/medicines/${id}`, { method: 'DELETE' });
    if (!r.ok) throw new Error('Delete failed');
    showToast('Deleted ' + id);
    await loadMedicinesPage();
  } catch (e) {
    console.error(e);
    alert('Error deleting medicine');
  }
}

// Sorting clicks
document.addEventListener('click', (ev)=>{
  const th = ev.target.closest('th.sortable');
  if (!th) return;
  const key = th.dataset.key;
  if (currentSort.key === key) currentSort.dir = (currentSort.dir === 'asc' ? 'desc' : 'asc');
  else { currentSort.key = key; currentSort.dir = 'asc'; }
  refreshTable();
});

// pagination controls
document.getElementById('prevPage')?.addEventListener('click', ()=>{
  if (currentPage > 1) { currentPage--; refreshTable(); }
});
document.getElementById('nextPage')?.addEventListener('click', ()=>{
  currentPage++; refreshTable();
});
document.getElementById('perPage')?.addEventListener('change', ()=>{
  currentPage = 1; refreshTable();
});

// filters & search events (debounced)
let searchTimeout = null;
['globalSearchBox','filterExpiry','filterStock','filterSupplier','filterCategory'].forEach(id=>{
  document.getElementById(id)?.addEventListener('input', ()=> {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(()=> { currentPage = 1; refreshTable(); }, 250);
  });
});

// CSV export
document.getElementById('btnExportCsv')?.addEventListener('click', ()=>{
  const filtered = applyFiltersAndSort(allMeds);
  const rows = filtered.map(m => ({
    id: m.medicine_id, name: m.name, batch: m.batch_number,
    expiry: m.expiry_date, qty: m.quantity, supplier: m.supplier_id, price: m.price
  }));
  const csv = [
    Object.keys(rows[0] || {}).join(','),
    ...rows.map(r => Object.values(r).map(v => `"${String(v ?? '')}"`).join(','))
  ].join('\n');
  const a = document.createElement('a');
  a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
  a.download = 'medicines_export.csv';
  a.click();
});

// page init
(async function init(){
  await fetchSuppliersAndCategories();
  await loadMedicinesPage();
})();
</script>
{% endblock %}
